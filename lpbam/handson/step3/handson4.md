# Cube IDE

<!--this whole chapter can be turned in presentation mode  -->

## File structure

### Project Explorer

  Apart from usual folders, we have a new LPBAM folder containing function needed to implement the functionality.
  Note that we got a folder called ADC which is the name of our LPBAM Application.

<!-- here we can add a description of what to expect in the various folders -->

![lpbam config](./img/01.png)

Note that `lpbam_adc.h` contains all the functions that needs to be called into `main.c`
We will not call DeInit, Stop and Unlink anyway this is a good trace to see the HAL generated by Cube Mx

```c
/* Exported functions ------------------------------------------------------------------------------------------------*/
/* ADC application initialization */
void MX_ADC_Init(void);

/* ADC application Scenario scenario initialization */
void MX_ADC_Scenario_Init(void);

/* ADC application Scenario scenario de-initialization */
void MX_ADC_Scenario_DeInit(void);

/* ADC application Scenario scenario build */
void MX_ADC_Scenario_Build(void);

/* ADC application Scenario scenario link */
void MX_ADC_Scenario_Link(DMA_HandleTypeDef *hdma);

/* ADC application Scenario scenario unlink */
void MX_ADC_Scenario_UnLink(DMA_HandleTypeDef *hdma);

/* ADC application Scenario scenario start */
void MX_ADC_Scenario_Start(DMA_HandleTypeDef *hdma);

/* ADC application Scenario scenario stop */
void MX_ADC_Scenario_Stop(DMA_HandleTypeDef *hdma);

#endif /* LPBAM_ADC_H */
```
# main.c

Let's start with including the LPBAM Library header file
```c
/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "lpbam_adc.h"
```

We also need `stdio.h` for UART output from ADC

```c
/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
#include "stdio.h"
/* USER CODE END PTD */
```

Let's also add the two handlers we will use for DMA <!-- need to double check this -->

```c
/* USER CODE BEGIN PV */
DMA_HandleTypeDef *LPBAM_ADC_Scenario_DMAHandlers[2];
/* USER CODE END PV */
```
We also have to place buffer for ADC
```c
/* USER CODE BEGIN 0 */
uint16_t aData_Sequence1[320] = {0U};
/* USER CODE END 0 */

```

Now we have to add HAL to enter in Stop2 mode
Let's start with the prototype:
<!--this approach should be reviewed vs standard HAL -->
```c
/* USER CODE BEGIN PFP */
static void Enter_Stop2_Mode(void);
```
And now let's add the definition:

```c
/* USER CODE BEGIN 4 */
static void Enter_Stop2_Mode(void)
{
  /* Enter the system to STOP2 mode */
  __HAL_RCC_PWR_CLK_ENABLE();
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);

  /* Check that the system was resumed from stop 2 */
  if (__HAL_PWR_GET_FLAG(PWR_FLAG_STOPF) == 0U)
  {
    Error_Handler();
  }

  /* Clear stop flag */
  __HAL_PWR_CLEAR_FLAG(PWR_FLAG_STOPF);

  /* Check that stop flag is cleared */
  if (__HAL_PWR_GET_FLAG(PWR_FLAG_STOPF) != 0U)
  {
    Error_Handler();
  }
}
```
Now let's copy the function which are part of `lpbam_adc.h` to initialize LPBAM, build the scenario, link and start.
We also added a button to be pressed in order to enter in STOP2 mode

<!--button point should e reviewed we probably do not need interrupt on user button pin and we need to set correctly PB7 in cube MX -->

```c
/* USER CODE BEGIN 2 */
    while (HAL_GPIO_ReadPin(USER_BUTTON_GPIO_Port, USER_BUTTON_Pin) != GPIO_PIN_SET)


  {
	  HAL_GPIO_TogglePin (GPIOB, GPIO_PIN_7);
	  HAL_Delay (100);   /* Insert delay 100 ms */

  }

  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_RESET);


     MX_ADC_Init();
  /* LPBAM ADC application InSwitch init */
     MX_ADC_Scenario_Init();
        /* LPBAM ADC application InSwitch build */
     MX_ADC_Scenario_Build();


     LPBAM_ADC_Scenario_DMAHandlers[0U] = &handle_LPDMA1_Channel0;
     LPBAM_ADC_Scenario_DMAHandlers[1U] = &handle_LPDMA1_Channel1;
     /* LPBAM ADC application InSwitch link */
     MX_ADC_Scenario_Link(  LPBAM_ADC_Scenario_DMAHandlers[0U]);


     /* LPBAM ADC application InSwitch start */
     MX_ADC_Scenario_Start(LPBAM_ADC_Scenario_DMAHandlers[0U]);
```
Below `MX_ADC_Scenario_Start` let's place a few functions to furtherly reduce power consumption and move to Stop2 power mode

*NOTE* Please remeber to stay inside the `/* USER CODE BEGIN 2` and `/* USER CODE END 2` sections otherwise content will be deleted upon next code generation via CubeMx

```c
HAL_FLASHEx_EnablePowerDown(FLASH_BANK_2);
     /* Configuration of the LPM read mode*/
     HAL_FLASHEx_ConfigLowPowerRead(FLASH_LPM_ENABLE);
    HAL_DBGMCU_DisableDBGStopMode();
    HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
```
<!-- check if we need to add debug mx or some macros as well -->

*Optionally you can add Debug pins PA5,PA6,PA7 to be able to debug SRD in STOP2 mode*

This code has to be added in `/* USER CODE BEGIN 4 */` section

```c
static void MX_DEBUG_Init(void)


{
	  GPIO_InitTypeDef GPIO_InitStruct = {0};

	  /* GPIO Ports Clock Enable */

	  __HAL_RCC_GPIOA_CLK_ENABLE();


	GPIO_InitStruct.Pin = GPIO_PIN_5;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF0_CSLEEP;
	  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	   GPIO_InitStruct.Pin = GPIO_PIN_6;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF0_CSTOP;
	  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);


	     GPIO_InitStruct.Pin = GPIO_PIN_7;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF0_SRDSTOP;
	  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
}
```

add `MX_DEBUG_Init();` in `/* USER CODE BEGIN 2 */` section and its prototype `static void MX_DEBUG_Init(void);` in `/* USER CODE BEGIN PFP */`

<!-- we'd better use PWR configurator in cube MX to show that-->

# LPBAM 

Let's move now to the LPBAM folder
 in `lpbam_adc_scenario_build` let's add `extern uint16_t aData_Sequence1[];` under `/* USER CODE BEGIN EV */`. This will contain the ADC buffer.

in `adc_scenario_build.c` let's modify the `MX_adc_Q_Build (void)` which is around line #128.

<!--IMPORTANT: THIS IS ACTUALLY A BUG MYDATASIZE AND BUFFER NAME GENERIC ARE MENTIONED INSTEAD OF ADATASEQUENCE AND 320 -->

```c
static void MX_adc_Q_Build(void)
{
  /* LPBAM build variable */
  LPBAM_DMAListInfo_t pDMAListInfo_ADC = {0};
  LPBAM_ADC_DataAdvConf_t pConvData_ADC = {0};

  /**
    * adc queue Conversion_data_5 build
    */
  pDMAListInfo_ADC.QueueType = LPBAM_LINEAR_ADDRESSING_Q;
  pDMAListInfo_ADC.pInstance = LPDMA1;
  pConvData_ADC.DMAContinuousRequests = DISABLE;
  pConvData_ADC.Size = 320;
  pConvData_ADC.pData = (uint32_t*)&aData_Sequence1[0];
  if (ADV_LPBAM_ADC_Conversion_SetDataQ(ADC4, &pDMAListInfo_ADC, &pConvData_ADC, &Conversion_data_7_Desc, &adc_Q) != LPBAM_OK)
  {
    Error_Handler();
  }

```
Now, let's move to `lpbam_adc_scenario_config.c`
Right above `/* USER CODE BEGIN PFP */` please add
the DMA NVIC configuration, Transfer complete callback prototypes and DMA Handler array.

`NOTE: We have an array sized two as we are using two LPDMA Channels`

```c
/* USER CODE BEGIN PFP */
/* LPBAM DMA user callback APIs */
static void MX_adc_Q_DMA_TC_Callback(DMA_HandleTypeDef *hdma);
/* LPBAM DMA NVIC API */
static void MX_DMA_NVIC_Config(DMA_HandleTypeDef *hdma, uint32_t PreemptPriority, uint32_t SubPriority);

DMA_HandleTypeDef *LPBAM_ADC_Scenario_DMAHandlers[2];
/* USER CODE END PFP */
```
Inside function definition `void MX_ADC_Scenario_Link(DMA_HandleTypeDef *hdma)` comment/remove `MX_adc_Q_Link(&hdma[ADC_Q_IDX]);`
and add the below

```c
/* USER CODE BEGIN LINK ADC_Q_IDX */
 MX_adc_Q_Link( LPBAM_ADC_Scenario_DMAHandlers[1U]);
  /* USER CODE END LINK ADC_Q_IDX */
```

in `MX_ADC_Scenario_Start` add the below and remove `(HAL_DMAEx_List_Start(&hdma[ADC_Q_IDX]) != HAL_OK)`

```c
  /* USER CODE BEGIN ADC_Scenario_Start */
if (HAL_DMAEx_List_Start ( LPBAM_ADC_Scenario_DMAHandlers[1U]) != HAL_OK)
      {
        Error_Handler();
      }

/* USER CODE END ADC_Scenario_Start */
```

in function `MX_ADC4_MspInit` please add the below 
```c
  /* USER CODE BEGIN ADC4_MspInit 0 */
   HAL_PWREx_EnableVddA();
  /* USER CODE END ADC4_MspInit 0 */
  ```

  NOTE: Next step is only for debug purposes of the Smart Run Domain.
  If we want to see timer output on an IO we can add the below code inside `MX_LPTIM1_MspInit`

```c
  /* USER CODE BEGIN LPTIM1_MspInit 1 */
__HAL_RCC_GPIOC_CLK_ENABLE();
       /**LPTIM1 GPIO Configuration
       PC1     ------> LPTIM1_CH1
       */
       GPIO_InitStruct.Pin = GPIO_PIN_1;
       GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
       GPIO_InitStruct.Pull = GPIO_NOPULL;
       GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
       GPIO_InitStruct.Alternate = GPIO_AF1_LPTIM1;
       HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  /* USER CODE END LPTIM1_MspInit 1 */
```

<!--need to check regardin   hdma->InitLinkedList.TransferEventMode = DMA_TCEM_LAST_LL_ITEM_TRANSFER; -->

in `MX_adc_Q_Link` replace the below code
only real actual modifications are priotity and block transfer
<awarning> 
Remember to enable DMA IT
</awarning>


```c
static void MX_adc_Q_Link(DMA_HandleTypeDef *hdma)
{
  /* Enable LPDMA1 clock */
  __HAL_RCC_LPDMA1_CLK_ENABLE();

  hdma->InitLinkedList.Priority = DMA_HIGH_PRIORITY;
  hdma->InitLinkedList.LinkStepMode = DMA_LSM_FULL_EXECUTION;
  hdma->InitLinkedList.TransferEventMode = DMA_TCEM_REPEATED_BLOCK_TRANSFER;
  hdma->InitLinkedList.LinkedListMode = DMA_LINKEDLIST_NORMAL;
  if (HAL_DMAEx_List_Init(hdma) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_DMAEx_List_LinkQ(hdma, &adc_Q) != HAL_OK)
  {
    Error_Handler();
  }
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TC);
  if (HAL_DMA_ConfigChannelAttributes(hdma, DMA_CHANNEL_NPRIV) != HAL_OK)
  {
    Error_Handler();
  }

  if (HAL_DMA_RegisterCallback(hdma, HAL_DMA_XFER_CPLT_CB_ID, MX_adc_Q_DMA_TC_Callback) != HAL_OK)
  {
    Error_Handler();
  }
  MX_DMA_NVIC_Config(hdma, 0, 0);

  ```

  add last section on LPDMA NVIC config

  ```c

  static void MX_DMA_NVIC_Config(DMA_HandleTypeDef *hdma, uint32_t PreemptPriority, uint32_t SubPriority)
{
  IRQn_Type irq = LPDMA1_Channel0_IRQn;

  /* Check DMA channel instance */
  switch ((uint32_t)hdma->Instance)
  {
    case (uint32_t)LPDMA1_Channel0: /* DMA channel_0 */
    {
      irq = LPDMA1_Channel0_IRQn;
      break;
    }

    case (uint32_t)LPDMA1_Channel1: /* DMA channel_1 */
    {
      irq = LPDMA1_Channel1_IRQn;
      break;
    }

    case (uint32_t)LPDMA1_Channel2: /* DMA channel_2 */
    {
      irq = LPDMA1_Channel2_IRQn;
      break;
    }

    case (uint32_t)LPDMA1_Channel3: /* DMA channel_3 */
    {
      irq = LPDMA1_Channel3_IRQn;
      break;
    }
  }

  /* Enable NVIC for DMA channel */
  HAL_NVIC_SetPriority(irq, PreemptPriority, SubPriority);
  HAL_NVIC_EnableIRQ(irq);
}
```