----!
Presentation
----!

# 1- File structure 

## Project Explorer

  Apart from usual folders, we have a new LPBAM folder containing function needed to implement the functionality.
  Note that we got a subfolder called **Lpbamap1** which is the name of our LPBAM Application.

---

<!-- here we can add a description of what to expect in the various folders -->
---
![lpbam config](./img/01.png)

**Note** `lpbam_lpbamp1.h`  is the entry point to LPBAM configuration, it contains all the functions that needs to be called into `main.c`
We will not call DeInit, Stop and Unlink anyway this is a good trace to see the HAL generated by Cube Mx.

---
<ainfo>
Exact content of each .c and .h file inside LpbamAp1 and related functions will be described in chapter 7
</ainfo>

---

```c-nc
/* Exported functions ------------------------------------------------------------------------------------------------*/
/* LpbamAp1 application initialization */
void MX_LpbamAp1_Init(void);

/* LpbamAp1 application Scenario scenario initialization */
void MX_LpbamAp1_Scenario_Init(void);

/* LpbamAp1 application Scenario scenario de-initialization */
void MX_LpbamAp1_Scenario_DeInit(void);

/* LpbamAp1 application Scenario scenario build */
void MX_LpbamAp1_Scenario_Build(void);

/* LpbamAp1 application Scenario scenario link */
void MX_LpbamAp1_Scenario_Link(DMA_HandleTypeDef *hdma);

/* LpbamAp1 application Scenario scenario unlink */
void MX_LpbamAp1_Scenario_UnLink(DMA_HandleTypeDef *hdma);

/* LpbamAp1 application Scenario scenario start */
void MX_LpbamAp1_Scenario_Start(DMA_HandleTypeDef *hdma);

/* LpbamAp1 application Scenario scenario stop */
void MX_LpbamAp1_Scenario_Stop(DMA_HandleTypeDef *hdma);

```
# 2- main.c 

Let's start by including the LPBAM Library header file
* Note is named after the Scenario, might change if you provided a different name to it
  
```c
/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "lpbam_lpbamap1.h"
```

We also need `stdio.h` for UART output from ADC

```c
/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
#include "stdio.h"
/* USER CODE END PTD */
```

we have to redirect write function to USART1

```c
  /* USER CODE BEGIN 4 */

int _write(int fd, char * ptr, int len)
 {
   HAL_UART_Transmit(&huart1,(uint8_t *)ptr,len,HAL_MAX_DELAY);
   return len;
 }

/* USER CODE END 4 */
```
Now let's add printf in *while(1)* to check if ADC is working correctly once we wakeup from STOP2 in addition we add a slow 1s blinking BLUE_LED t get confirmation of STM32U5 being in running mode

```c
       /* USER CODE BEGIN 3 */
   HAL_GPIO_TogglePin (LED_BLUE_GPIO_Port, LED_BLUE_Pin);
                HAL_Delay (1000);

int i;
for (i=0;i < (sizeof (Data_Sequence) /sizeof (Data_Sequence[0]));

i++)

printf(" Data_Sequence[%d] = %d\n",i,Data_Sequence[i]);
;
                }

                 HAL_Delay(1000);
```


Let's also add the array containing adresses for the two DMA handlers 

```c
/* USER CODE BEGIN PV */
 DMA_HandleTypeDef *LPBAM_LpbamAp1_Scenario_DMAHandlers[2];
/* USER CODE END PV */
```
We also have to place buffer for ADC

```c
/* USER CODE BEGIN 0 */
uint16_t Data_Sequence[320] = {0U};
/* USER CODE END 0 */
```

Now we copy the function which are part of `lpbam_adc.h` to initialize LPBAM, build the scenario, link and start.
We also added a blue led and user button to be pressed in order to enter in STOP2 mode

<!--button point should e reviewed we probably do not need interrupt on user button pin and we need to set correctly PB7 in cube MX -->

```c
/* USER CODE BEGIN 2 */
  while (HAL_GPIO_ReadPin(USER_BUTTON_GPIO_Port, USER_BUTTON_Pin) != GPIO_PIN_SET)


{
	  HAL_GPIO_TogglePin (LED_BLUE_GPIO_Port, LED_BLUE_Pin);
	  HAL_Delay (100);   /* Insert delay 100 ms */

}

HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_RESET);


     MX_LpbamAp1_Init();
/* LPBAM ADC application InSwitch init */
   MX_LpbamAp1_Scenario_Init();
      /* LPBAM ADC application InSwitch build */
   MX_LpbamAp1_Scenario_Build();


   LPBAM_LpbamAp1_Scenario_DMAHandlers[0U] = &handle_LPDMA1_Channel0;
   LPBAM_LpbamAp1_Scenario_DMAHandlers[1U] = &handle_LPDMA1_Channel1;
   /* LPBAM ADC application InSwitch link */
   MX_LpbamAp1_Scenario_Link(  LPBAM_LpbamAp1_Scenario_DMAHandlers[0U]);


   /* LPBAM ADC application InSwitch start */
   MX_LpbamAp1_Scenario_Start(LPBAM_LpbamAp1_Scenario_DMAHandlers[0U]);
```
Below `MX_LpbamAp1_Scenario_Start` let's place
the function to Enable/Disable the debug in STOP mode and to enter in STOP2 Mode 

*NOTE* Please remeber to stay inside the `/* USER CODE BEGIN 2` and `/* USER CODE END 2` sections otherwise content will be deleted upon next code generation via CubeMx


```c
    HAL_DBGMCU_DisableDBGStopMode();
    HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
```
<!-- check if we need to add debug mx or some macros as well -->

---

## 3- LPBAM 

Let's move now to the LPBAM folder
 in `lpbam_lpbamp1_scenario_build` let's add buffer declaration under `/* USER CODE BEGIN EV */`. This will contain the ADC buffer.

 ```c
/* USER CODE BEGIN EV */
extern uint8_t Data_Sequence[320];
/* USER CODE END EV */
 ```
now in `lpbam_lpbamp1_scenario_config`
in function `MX_ADC4_MspInit` please add the below 

```c
  /* USER CODE BEGIN ADC4_MspInit 0 */
   HAL_PWREx_EnableVddA();
  /* USER CODE END ADC4_MspInit 0 */
```

  ## 4- Linker

  Linker file should be modified as follows.
  
Basically you can delete SRAM4 and redefine a new one

```c
MEMORY
{
  RAM	(xrw)	: ORIGIN = 0x28000000,	LENGTH = 16K
  FLASH	(rx)	: ORIGIN = 0x08000000,	LENGTH = 2048K
}
```

`Note` in standard application with wider use of power modes and peripheral you might need to place buffers and DMA ahndlers in dedicated SRAM4 section by using __attribute__ e.g. `uint16_t buffer_adc[64] __attribute__((section(".sram4")))`;


<ainfo>
The LPBAM utility includes two types of variables:

1- Variables used by the program executed by CPU. They can be placed at any available SRAM address.

2- Variables used by the DMA in order to execute linked-list queue. They must be placed at SRAM addresses accessible by the DMA instance. These variables are LPBAM descriptors and data buffers.

=> To optimize memory usage, it is recommended to place only the variables used during linked-list queue execution in SRAM4 when the LPBAM scenario is built to be executed by the LPDMA.

</ainfo>
---

## 5 - Extra

NOTE: Next step is only for debug purposes of the Smart Run Domain.
  If we want to see timer output on an IO we can add the below code inside `MX_LPTIM1_MspInit`

```c
  /* USER CODE BEGIN LPTIM1_MspInit 1 */
__HAL_RCC_GPIOC_CLK_ENABLE();
       /**LPTIM1 GPIO Configuration
       PC1     ------> LPTIM1_CH1
       */
       GPIO_InitStruct.Pin = GPIO_PIN_1;
       GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
       GPIO_InitStruct.Pull = GPIO_NOPULL;
       GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
       GPIO_InitStruct.Alternate = GPIO_AF1_LPTIM1;
       HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  /* USER CODE END LPTIM1_MspInit 1 */
```
