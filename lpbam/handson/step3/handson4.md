----!
Presentation
----!

<!-- # **Cube IDE** #  -->

<!--this whole chapter can be turned in presentation mode  -->

# 1- File structure

## Project Explorer

  Apart from usual folders, we have a new LPBAM folder containing function needed to implement the functionality.
  Note that we got a subfolder called **Lpbamap1** which is the name of our LPBAM Application.

---

<!-- here we can add a description of what to expect in the various folders -->

![lpbam config](./img/01.png)

**Note**: `lpbam_lpbamp1.h`  is the entry point to LPBAM configuration, it contains all the functions that needs to be called into `main.c`
We will not call DeInit, Stop and Unlink anyway this is a good trace to see the HAL generated by Cube Mx.


<ainfo>
Exact content of each .c and .h file inside LpbamAp1 and related functions will be described in chapter 7
</ainfo>

---

```c-nc
/* Exported functions ------------------------------------------------------------------------------------------------*/
/* LpbamAp1 application initialization */
void MX_LpbamAp1_Init(void);

/* LpbamAp1 application Scenario scenario initialization */
void MX_LpbamAp1_Scenario_Init(void);

/* LpbamAp1 application Scenario scenario de-initialization */
void MX_LpbamAp1_Scenario_DeInit(void);

/* LpbamAp1 application Scenario scenario build */
void MX_LpbamAp1_Scenario_Build(void);

/* LpbamAp1 application Scenario scenario link */
void MX_LpbamAp1_Scenario_Link(DMA_HandleTypeDef *hdma);

/* LpbamAp1 application Scenario scenario unlink */
void MX_LpbamAp1_Scenario_UnLink(DMA_HandleTypeDef *hdma);

/* LpbamAp1 application Scenario scenario start */
void MX_LpbamAp1_Scenario_Start(DMA_HandleTypeDef *hdma);

/* LpbamAp1 application Scenario scenario stop */
void MX_LpbamAp1_Scenario_Stop(DMA_HandleTypeDef *hdma);

```
# 2 - main.c

Let's start by including the LPBAM Library header file in `
 `/* USER CODE BEGIN Includes */ `

**Note** is named after the Scenario, might change if you provided a different name to it
  
```c
#include "lpbam_lpbamap1.h"
```
in   `/* USER CODE BEGIN 1 */` we add

```c
	int round = 0 ;
```
Let's also add the array containing adresses for the two DMA handlers in `/* USER CODE BEGIN PV */`

```c
 DMA_HandleTypeDef *LPBAM_LpbamAp1_Scenario_DMAHandlers[2];
```
We also have to place buffer for ADC
in `/* USER CODE BEGIN 0 */`

```c
uint16_t Data_Sequence[320] = {0U};
```

Now we copy the function which are part of `lpbam_adc.h` to initialize LPBAM, build the scenario, link and start. Reference section is `/* USER CODE BEGIN 2 */ `  

```c
     MX_LpbamAp1_Init();
/* LPBAM ADC application InSwitch init */
   MX_LpbamAp1_Scenario_Init();
      /* LPBAM ADC application InSwitch build */
   MX_LpbamAp1_Scenario_Build();


   LPBAM_LpbamAp1_Scenario_DMAHandlers[0U] = &handle_LPDMA1_Channel0;
   LPBAM_LpbamAp1_Scenario_DMAHandlers[1U] = &handle_LPDMA1_Channel1;
   /* LPBAM ADC application InSwitch link */
   MX_LpbamAp1_Scenario_Link(  LPBAM_LpbamAp1_Scenario_DMAHandlers[0U]);

   /* LPBAM ADC application InSwitch start */
   MX_LpbamAp1_Scenario_Start(LPBAM_LpbamAp1_Scenario_DMAHandlers[0U]);
```
Below `MX_LpbamAp1_Scenario_Start` let's place
the function to Enable/Disable the debug in STOP mode and to enter in STOP2 Mode 

<ainfo>
Please remeber to stay inside the `/* USER CODE BEGIN 2` and `/* USER CODE END 2` sections otherwise content will be deleted upon next code generation via CubeMx
</ainfo>

```c
    HAL_DBGMCU_DisableDBGStopMode();
    HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
```
<!-- check if we need to add debug mx or some macros as well -->

<ainfo>
 `HAL_DBGMCU_DisableDBGStopMode` is the function contributing the most to low power, it stops clock from being distributed over the debug interface
</ainfo>

---
# 3- LPBAM 

Let's move now to the LPBAM folder
 in `lpbam_lpbamp1_scenario_build` let's add buffer declaration under `/* USER CODE BEGIN EV */`. This will contain the ADC buffer.

 ```c
extern uint8_t Data_Sequence[320];
 ```
now in `lpbam_lpbamp1_scenario_config`
in function `MX_ADC4_MspInit`  in `USER CODE BEGIN ADC4_MspInit 0` please add the below 

```c

   HAL_PWREx_EnableVddA();
```

  # 4- Linker

  Linker file should be modified as follows.
  
Basically you can delete SRAM4 and redefine a new one

```c
MEMORY
{
  RAM	(xrw)	: ORIGIN = 0x28000000,	LENGTH = 16K
  FLASH	(rx)	: ORIGIN = 0x08000000,	LENGTH = 2048K
}
```

`Note` in standard application with wider use of power modes and peripheral you might need to place buffers and DMA ahndlers in dedicated SRAM4 section by using __attribute__ e.g. `uint16_t buffer_adc[64] __attribute__((section(".sram4")))`;


<ainfo>
The LPBAM utility includes two types of variables:

1- Variables used by the program executed by CPU. They can be placed at any available SRAM address.

2- Variables used by the DMA in order to execute linked-list queue. They must be placed at SRAM addresses accessible by the DMA instance. These variables are LPBAM descriptors and data buffers.

=> To optimize memory usage, it is recommended to place only the variables used during linked-list queue execution in SRAM4 when the LPBAM scenario is built to be executed by the LPDMA.

</ainfo>
---

# 6 - Extra

NOTE: Next step is only for debug purposes of the Smart Run Domain.
  If we want to see timer output on an IO we can add the below code inside `MX_LPTIM1_MspInit` in 
  `USER CODE BEGIN LPTIM1_MspInit`

```c
GPIO_InitTypeDef GPIO_InitStruct = {0};

__HAL_RCC_GPIOC_CLK_ENABLE();
       /**LPTIM1 GPIO Configuration
       PC1     ------> LPTIM1_CH1
       */
       GPIO_InitStruct.Pin = GPIO_PIN_1;
       GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
       GPIO_InitStruct.Pull = GPIO_NOPULL;
       GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
       GPIO_InitStruct.Alternate = GPIO_AF1_LPTIM1;
       HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  /* USER CODE END LPTIM1_MspInit 1 */
```
